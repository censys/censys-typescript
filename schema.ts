/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

export interface paths {
  "/v2/hosts/search": {
    /**
     * Accepts queries for host or service attributes provided in the Censys Search Language and returns a list of matching hosts with some summary fields.
     *
     * **Cursor Pagination**
     *
     * Search endpoints rely on using cursors for efficient pagination.
     *
     * Each search result may return a `next` and `prev` cursor value which can be used to fetch additional pages of results.
     *
     * ```json
     * {
     * 	"links":{
     * 		"prev":"prevCursorToken",
     * 		"next":"nextCursorToken"
     * 	},
     * 	[Rest of Response]
     * }
     * ```
     * The returned cursor token values can be added to the search endpoint as a `cursor` parameter to fetch either the next page of results or the previous page.
     *
     * The entire set of results can be iterated page-by-page using returned cursors. If no cursor is given, the first page will be returned.
     */
    get: operations["searchHosts"];
  };
  "/v2/hosts/aggregate": {
    /** Aggregates hosts that match the given query string into buckets based on the given field. See help on the Censys Search Language for help on constructing a search query. */
    get: operations["aggregateHosts"];
  };
  "/v2/hosts/{ip}": {
    /** Fetches the entire host entity by IP address and returns the most recent Censys view of the host and its services. */
    get: operations["viewHost"];
  };
  "/v2/hosts/{ip}/diff": {
    /**
     * The diff endpoint generates a JSONPatch (RFC6902) formatted patch by comparing a host against another host (or itself) at
     * optionally given points in time.
     *
     * The host as specified by the IP in the path and the `at_time` parameter is referred to as the original host, or simply "A".
     * The host specified by the parameters `ip_b` and `at_time_b` is referred to as "B".
     *
     * The differential generated provides a sequence of steps needed to transform Host A into Host B.
     */
    get: operations["viewHostDiff"];
  };
  "/v2/experimental/hosts/{ip}/events": {
    /**
     * Fetches a list of events for the host with the specified IP address.
     *
     * **Cursor Pagination**
     *
     * This endpoint relies on using cursors for efficient pagination. Each result may
     * return a `next` cursor value which can be used to fetch additional pages of results.
     * This endpoint only support forward-pagination.
     *
     * ```json
     * {
     *   "links": {
     *     "next": "nextCursorToken"
     *   },
     *   [Rest of Response]
     * }
     * ```
     * The returned cursor token values can be added to the endpoint as a `cursor`
     * parameter to fetch the next page of results.
     * The entire set of results can be iterated page-by-page using returned
     * cursors. If no cursor is given, the first page will be returned.
     */
    get: operations["viewHostEvents"];
  };
  "/v2/hosts/{ip}/names": {
    /** Fetches a list of host names for the specified IP address. */
    get: operations["viewHostNames"];
  };
  "/v2/hosts/{ip}/comments": {
    /** Returns a list of comments on the given host. */
    get: operations["getCommentsByHost"];
    /** Adds a comment on the given host. */
    post: operations["addCommentByHost"];
  };
  "/v2/hosts/{ip}/comments/{comment_id}": {
    /** Returns a specific comment on the given host. */
    get: operations["getCommentByHost"];
    /** Updates a specific comment on the given host. */
    put: operations["updateCommentByHost"];
    /** Deletes a specific comment on the given host. */
    delete: operations["deleteCommentByHost"];
  };
  "/v2/metadata/hosts": {
    /** The host metadata endpoint returns a list of services Censys scans for. These are the values that can be given as values for the `services.service_name` field in search queries. */
    get: operations["getHostMetadata"];
  };
  "/v2/certificates/{fingerprint}/hosts": {
    /**
     * Returns a list of hosts which contain services presenting this certificate,
     * including when the certificate was first observed.
     *
     * **Cursor Pagination**
     *
     * This endpoint relies on using cursors for efficient pagination. Each result may
     * return a `next` cursor value which can be used to fetch additional pages of results.
     * This endpoint only support forward-pagination.
     *
     * ```json
     * {
     *   "links": {
     *     "next": "nextCursorToken"
     *   },
     *   [Rest of Response]
     * }
     * ```
     * The returned cursor token values can be added to the endpoint as a `cursor`
     * parameter to fetch the next page of results.
     * The entire set of results can be iterated page-by-page using returned
     * cursors. If no cursor is given, the first page will be returned.
     */
    get: operations["getHostsByCert"];
  };
  "/v2/certificates/{fingerprint}/comments": {
    /** Returns a list of comments on the given certificate. */
    get: operations["getCommentsByCert"];
    /** Adds a comment on the given certificate. */
    post: operations["addCommentByCert"];
  };
  "/v2/certificates/{fingerprint}/comments/{comment_id}": {
    /** Returns a comment on the given certificate. */
    get: operations["getCommentByCert"];
    /** Updates a comment on the given certificate. */
    put: operations["updateCommentByCert"];
    /** Deletes a comment on the given certificate. */
    delete: operations["deleteCommentByCert"];
  };
  "/v1/view/certificates/{sha256}": {
    /**
     * > The Censys legacy v1 API contains API endpoints which are being maintained until replacement v2 endpoints are available.
     *
     * The view endpoint returns the current structured data we have on a specific certificate.
     */
    get: operations["viewCertificate"];
  };
  "/v1/search/certificates": {
    /**
     * > The Censys legacy v1 API contains API endpoints which are being maintained until replacement v2 endpoints are available.
     *
     * The search endpoint allows searches against the current data in the Certificates index using the [legacy search syntax](https://search.censys.io/certificates/help). The endpoint returns a paginated result set of hosts (or websites or certificates) that match the search. Data should be posted as a JSON request document.
     */
    post: operations["searchCertificates"];
  };
  "/v1/report/certificates": {
    /**
     * > The Censys legacy v1 API contains API endpoints which are being maintained until replacement v2 endpoints are available.
     *
     * The build report endpoint lets you run aggregate reports on the breakdown of a field in a result set analogous to the "Build Report" functionality in the front end.
     */
    post: operations["generateCertificateReport"];
  };
  "/v1/bulk/certificates": {
    /**
     * > The Censys legacy v1 API contains API endpoints which are being maintained until replacement v2 endpoints are available.
     *
     * The bulk endpoint returns, in bulk, the current structured data on many specific certificates.
     *
     * Each requested certificate will be available as a key in the response, regardless of whether or not we know anything about them. Any certificates which we don't know anything about will be replaced by an error, as shown at the top of the example below.
     */
    post: operations["bulkCertificateLookup"];
  };
  "/v1/data": {
    /**
     * > The Censys legacy v1 API contains API endpoints which are being maintained until replacement v2 endpoints are available.
     *
     * The Get Series endpoint returns a data on the types of scans we regularly perform (series).
     */
    get: operations["getSeries"];
  };
  "/v1/data/{series}": {
    /**
     * > The Censys legacy v1 API contains API endpoints which are being maintained until replacement v2 endpoints are available.
     *
     * The View Series endpoint returns data we have about a particular series—a scan of the same protocol and destination across time—including the list of scans.
     */
    get: operations["viewSeries"];
  };
  "/v1/data/{series}/{result}": {
    /**
     * > The Censys legacy v1 API contains API endpoints which are being maintained until replacement v2 endpoints are available.
     *
     * The View Result endpoint returns data on a particular scan (result), as found in the Get Series or View Series endpoints.
     */
    get: operations["viewResult"];
  };
  "/v1/account": {
    /**
     * > The Censys legacy v1 API contains API endpoints which are being maintained until replacement v2 endpoints are available.
     *
     * The Account endpoint returns information about your Censys account. Most importantly, you can use this endpoint to check on your current query quota usage.
     */
    get: operations["account"];
  };
  "/v2/tags": {
    /** Returns a list of all tags for a team */
    get: operations["listTags"];
    /** Creates a new tag for a team */
    post: operations["createTag"];
  };
  "/v2/tags/{id}": {
    /** Returns a tag for a team */
    get: operations["getTag"];
    /** Updates a tag for a team */
    put: operations["updateTag"];
    /** Deletes a tag for a team */
    delete: operations["deleteTag"];
  };
  "/v2/tags/{id}/hosts": {
    /** Returns a list of hosts for a tag */
    get: operations["listHostsForTag"];
  };
  "/v2/tags/{id}/certificates": {
    /** Returns a list of certificates for a tag */
    get: operations["listCertificatesForTag"];
  };
  "/v2/hosts/{ip}/tags": {
    /** Returns a list of tags on the given host. */
    get: operations["getTagsByHost"];
  };
  "/v2/hosts/{ip}/tags/{id}": {
    /** Adds a tag on the given host. */
    put: operations["tagHost"];
    /** Removes a tag on the given host. */
    delete: operations["untagHost"];
  };
  "/v2/certificates/{fingerprint}/tags": {
    /** Returns a list of tags on the given certificate. */
    get: operations["getTagsByCert"];
  };
  "/v2/certificates/{fingerprint}/tags/{id}": {
    /** Adds a tag on the given certificate. */
    put: operations["tagCert"];
    /** Removes a tag on the given certificate. */
    delete: operations["untagCert"];
  };
}

export interface components {
  schemas: {
    /** Success Response (v2) */
    ApiResponse: {
      /** @example 200 */
      code?: number;
      /** @example OK */
      status?: string;
      result?: { [key: string]: unknown };
    };
    /** Error Response (v2) */
    ApiErrorResponse: {
      /** @example 422 */
      code?: number;
      /** @example Unprocessable Entity */
      status?: string;
      error?: string;
    };
    Host: {
      /** @example 1.1.1.1 */
      ip?: string;
      /**
       * @example [
       *   {
       *     "port": 53,
       *     "service_name": "DNS",
       *     "transport_protocol": "UDP",
       *     "extended_service_name": "DNS",
       *     "dns": {
       *       "server_type": "FORWARDING"
       *     }
       *   },
       *   {
       *     "port": 443,
       *     "service_name": "HTTP",
       *     "transport_protocol": "TCP",
       *     "extended_service_name": "HTTPS",
       *     "http": {
       *       "request": {
       *         "method": "GET",
       *         "uri": "https://1.1.1.1/",
       *         "headers": {
       *           "User_Agent": [
       *             "Mozilla/5.0 (compatible; CensysInspect/1.1; +https://about.censys.io/)"
       *           ],
       *           "Accept": [
       *             "*\/*"
       *           ]
       *         }
       *       },
       *       "response": {
       *         "body": "<!DOCTYPE html>...",
       *         "protocol": "HTTP/1.1",
       *         "body_size": 1000,
       *         "status_code": 404,
       *         "status_reason": "Not Found",
       *         "headers": {
       *           "Content_Length": [
       *             "<REDACTED>"
       *           ],
       *           "Content_Type": [
       *             "text/html; charset=UTF-8"
       *           ],
       *           "Server": [
       *             "HTTP server (unknown)"
       *           ],
       *           "Date": [
       *             "<REDACTED>"
       *           ]
       *         },
       *         "html_tags": [
       *           "<title>Error 404 (Not Found)!!1</title>",
       *           "<meta charset=utf-8>",
       *           "<meta name=viewport content=\"initial-scale=1, minimum-scale=1, width=device-width\">"
       *         ]
       *       }
       *     },
       *     "certificate": "e58e89a726d80bb0219b218c3ab9d818b4be75d77959508400d660ebe1c1be3d",
       *     "tls": {}
       *   }
       * ]
       */
      services?: ({
        port?: number;
        service_name?: string;
        extended_service_name?: string;
        transport_protocol?: string;
        software?: string[];
        /** @example false */
        truncated?: boolean;
        perspective_id?: components["x-partials"]["hosts"]["PerspectiveID"];
      } & { [key: string]: unknown })[];
      /** @example 2021-03-30T14:53:12.980328Z */
      location_updated_at?: string;
      location?: components["x-partials"]["hosts"]["Location"];
      /** @example 2021-04-09T17:33:12.118684Z */
      autonomous_system_updated_at?: string;
      autonomous_system?: components["x-partials"]["hosts"]["Routing"];
      operating_system?: {
        /** @example Linux */
        product?: string;
        /** @example Ubuntu */
        vendor?: string;
        /** @example 18.04 */
        version?: string;
        /** @example bionic */
        edition?: string;
        /** @example cpe:2.3:o:*:linux:*:*:*:*:*:*:*:* */
        uniform_resource_identifier?: string;
        other?: { [key: string]: unknown };
      };
    };
    HostHit: {
      /** @example 8.8.8.8 */
      ip?: string;
      /**
       * @example [
       *   {
       *     "port": 53,
       *     "service_name": "DNS",
       *     "transport_protocol": "UDP"
       *   },
       *   {
       *     "port": 443,
       *     "service_name": "HTTP",
       *     "transport_protocol": "TCP",
       *     "certificate": "e58e89a726d80bb0219b218c3ab9d818b4be75d77959508400d660ebe1c1be3d"
       *   }
       * ]
       */
      services?: ({
        port?: number;
        service_name?: string;
        transport_protocol?: string;
        certificate?: string;
      } & { [key: string]: unknown })[];
      location?: components["x-partials"]["hosts"]["Location"];
      autonomous_system?: components["x-partials"]["hosts"]["Routing"];
    };
    VirtualHostHit: {
      /** @example dns.google */
      name?: string;
    } & components["schemas"]["HostHit"];
    HostEvent: (
      | components["x-partials"]["hosts"]["ServiceObservedEvent"]
      | components["x-partials"]["hosts"]["LocationUpdatedEvent"]
      | components["x-partials"]["hosts"]["RoutingUpdatedEvent"]
      | components["x-partials"]["hosts"]["ServiceRemovedFromHostEvent"]
      | components["x-partials"]["hosts"]["ServiceAddedToHostEvent"]
    ) & {
      /**
       * @description Discriminator which provides the type of event this object represents.
       * @example service_observed
       */
      _event?: string;
      /** Format: date-time */
      timestamp?: string;
    };
    HostComment: {
      /** @example comment-id */
      id?: string;
      /** @example 1.1.1.1 */
      ip?: string;
      author_id?: string;
      /** @example **This is a comment.** */
      contents: string;
      /**
       * Format: date-time
       * @example 2016-01-01T00:00:00Z
       */
      created_at?: string;
    };
    CertComment: {
      /** @example comment-id */
      id?: string;
      /** @example 9d3b51a6b80daf76e074730f19dc01e643ca0c3127d8f48be64cf3302f6622cc */
      fingerprint?: string;
      author_id?: string;
      /** @example **This is a comment.** */
      contents: string;
      /**
       * Format: date-time
       * @example 2016-01-01T00:00:00Z
       */
      created_at?: string;
    };
    Tag: {
      /** Format: integer */
      id?: string;
      /** @example tag-name */
      name: string;
      metadata?: {
        /** @example ff6113 */
        color?: string;
      };
      /**
       * Format: date-time
       * @example 2021-01-01T00:00:00.000000000Z
       */
      created_at?: string;
      /**
       * Format: date-time
       * @example 2021-02-01T00:00:00.000000000Z
       */
      updated_at?: string;
    };
    /** Error Response (v1) */
    v1ApiErrorResponse: {
      /** @example 400 */
      error_code?: number;
      /** @example query could not be parsed */
      error?: string;
    };
    Certificate: {
      /** @example MIIDQ...G9rw= */
      raw?: string;
      parsed?: {
        /** @example 8740f09afc54752b26b295cdc6393c6b8ffd9e6a */
        fingerprint_sha1?: string;
        /** @example 9d3b51a6b80daf76e074730f19dc01e643ca0c3127d8f48be64cf3302f6622cc */
        fingerprint_sha256?: string;
        /** @example 0f263d5e56288c37ade29f7b9977f38d */
        fingerprint_md5?: string;
        /** @example 5878999135690491000 */
        serial_number?: string;
        subject_key_info?: { [key: string]: unknown };
        names?: string[];
        /** @example C=US, ST=California, L=Mountain View, O=Google Inc, CN=*.google.com */
        subject_dn?: string;
        subject?: { [key: string]: unknown };
        /** @example C=US, O=Google Inc, CN=Google Internet Authority G2 */
        issuer_dn?: string;
        issuer?: { [key: string]: unknown };
        signature?: { [key: string]: unknown };
        /** @example false */
        redacted?: boolean;
        validity?: { [key: string]: unknown };
        /** @example 3 */
        version?: number;
        extensions?: { [key: string]: unknown };
      };
      ct?: { [key: string]: unknown };
    };
  };
}

export interface operations {
  /**
   * Accepts queries for host or service attributes provided in the Censys Search Language and returns a list of matching hosts with some summary fields.
   *
   * **Cursor Pagination**
   *
   * Search endpoints rely on using cursors for efficient pagination.
   *
   * Each search result may return a `next` and `prev` cursor value which can be used to fetch additional pages of results.
   *
   * ```json
   * {
   * 	"links":{
   * 		"prev":"prevCursorToken",
   * 		"next":"nextCursorToken"
   * 	},
   * 	[Rest of Response]
   * }
   * ```
   * The returned cursor token values can be added to the search endpoint as a `cursor` parameter to fetch either the next page of results or the previous page.
   *
   * The entire set of results can be iterated page-by-page using returned cursors. If no cursor is given, the first page will be returned.
   */
  searchHosts: {
    parameters: {
      query: {
        /** Query used to search for hosts with matching attributes. Uses the Censys Search Language. */
        q?: string;
        /** The maximum number of hits to return in each response (minimum of 1, maximum of 100). */
        per_page?: number;
        /**
         * Determine how to query Virtual Hosts. The default is `EXCLUDE` which will ignore any virtual hosts entries.
         * When set to `INCLUDE` or `ONLY` virtual hosts will be present in the returned list of hits, with the later
         * returning only virtual hosts.
         *
         * To learn more, see the [Help Desk article on Virtual Hosts](https://support.censys.io/hc/en-us/articles/4411773845524).
         */
        virtual_hosts?: "EXCLUDE" | "INCLUDE" | "ONLY";
        /** Cursor token from the API response, which fetches the next or previous page of hits when added to the endpoint URL. */
        cursor?: string;
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          "application/json": components["schemas"]["ApiResponse"] & {
            result?: {
              /** @example service.service_name: HTTP */
              query?: string;
              /** @example 50000 */
              total?: number;
              hits?: (
                | components["schemas"]["HostHit"]
                | components["schemas"]["VirtualHostHit"]
              )[];
            };
            links?: {
              /** @example prevCursorToken */
              prev?: string;
              /** @example nextCursorToken */
              next?: string;
            };
          };
        };
      };
      /** Bad Request. */
      400: {
        content: {
          "application/json": components["schemas"]["ApiErrorResponse"];
        };
      };
      /** You must authenticate with a valid API ID and secret. */
      401: {
        content: {
          "application/json": components["schemas"]["ApiErrorResponse"];
        };
      };
      /** Invalid cursor. */
      422: {
        content: {
          "application/json": components["schemas"]["ApiErrorResponse"];
        };
      };
    };
  };
  /** Aggregates hosts that match the given query string into buckets based on the given field. See help on the Censys Search Language for help on constructing a search query. */
  aggregateHosts: {
    parameters: {
      query: {
        /** Query used to search for Hosts which will be aggregated. Query uses the Censys Search Language. */
        q?: string;
        /** The field used to aggregated upon and generate buckets for. If the field is a service level field, the aggregation result will be based on services which belong to hosts which match the query, not the hosts themselves. */
        field: string;
        /** The maximum number of buckets used to generate aggregate results. */
        num_buckets?: number;
        /**
         * Determine how to query Virtual Hosts. The default is `EXCLUDE` which will ignore any virtual hosts entries.
         * When set to `INCLUDE` or `ONLY` virtual hosts will be present in the returned list of hits, with the later
         * returning only virtual hosts.
         *
         * To learn more, see the [Help Desk article on Virtual Hosts](https://support.censys.io/hc/en-us/articles/4411773845524).
         */
        virtual_hosts?: "EXCLUDE" | "INCLUDE" | "ONLY";
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          "application/json": components["schemas"]["ApiResponse"] & {
            result?: {
              /** @example 500000 */
              total?: number;
              /** @example 500000 */
              total_omitted?: number;
              /** @example 5000 */
              potential_deviation?: number;
              buckets?: {
                /** @example 80 */
                key?: string;
                /** @example 50000 */
                count?: number;
              }[];
              /** @example service.service_name: HTTP */
              query?: string;
              /** @example services.port */
              field?: string;
            };
          };
        };
      };
      /** Bad Request. */
      400: {
        content: {
          "application/json": components["schemas"]["ApiErrorResponse"];
        };
      };
      /** You must authenticate with a valid API ID and secret. */
      401: {
        content: {
          "application/json": components["schemas"]["ApiErrorResponse"];
        };
      };
    };
  };
  /** Fetches the entire host entity by IP address and returns the most recent Censys view of the host and its services. */
  viewHost: {
    parameters: {
      path: {
        /** The IP Address of the requested host. */
        ip: string;
      };
      query: {
        /**
         * Fetches the Censys view of a host and its services at the specified point in time. Requires historical API access.
         * Nanosecond precision is allowed. Uses RFC3339 Timestamp.
         */
        at_time?: string;
      };
    };
    responses: {
      /** The host was successfully retrieved. */
      200: {
        content: {
          "application/json": components["schemas"]["ApiResponse"] & {
            result?: components["schemas"]["Host"] & {
              /** Format: date-time */
              last_updated_at?: string;
              /** Format: date-time */
              location_updated_at?: string;
              /** Format: date-time */
              autonomous_system_updated_at?: string;
            };
          };
        };
      };
      /** You must authenticate with a valid API ID and secret. */
      401: {
        content: {
          "application/json": components["schemas"]["ApiErrorResponse"];
        };
      };
      /** Invalid IP address. */
      422: {
        content: {
          "application/json": components["schemas"]["ApiErrorResponse"];
        };
      };
    };
  };
  /**
   * The diff endpoint generates a JSONPatch (RFC6902) formatted patch by comparing a host against another host (or itself) at
   * optionally given points in time.
   *
   * The host as specified by the IP in the path and the `at_time` parameter is referred to as the original host, or simply "A".
   * The host specified by the parameters `ip_b` and `at_time_b` is referred to as "B".
   *
   * The differential generated provides a sequence of steps needed to transform Host A into Host B.
   */
  viewHostDiff: {
    parameters: {
      path: {
        /** The IP Address of the original host. Referred to as Host A. */
        ip: string;
      };
      query: {
        /** The IP Address of the other host. If not set, defaults to the host provided in the path. Referred to as Host B. */
        ip_b?: string;
        /**
         * The point in time used as the basis for Host A.
         *
         * Requires historical API access.
         * Nanosecond precision is allowed. Uses RFC3339 Timestamp.
         */
        at_time?: string;
        /**
         * The point in time used as the basis for Host B.
         *
         * Requires historical API access.
         * Nanosecond precision is allowed. Uses RFC3339 Timestamp.
         */
        at_time_b?: string;
      };
    };
    responses: {
      /** A diff was successfully generated for the given host(s). */
      200: {
        content: {
          "application/json": components["schemas"]["ApiResponse"] & {
            result?: {
              a?: {
                /** @description The IP address of the original host. */
                ip?: string;
                /**
                 * Format: date-time
                 * @description Returned updated timestamp of the original host.
                 */
                last_updated_at?: string;
              };
              b?: {
                /** @description The IP address of the other host. */
                ip?: string;
                /**
                 * Format: date-time
                 * @description Returned updated timestamp of the other host.
                 */
                last_updated_at?: string;
              };
              /** Format: jsonpatch */
              patch?: { [key: string]: unknown }[];
            };
          };
        };
      };
      /** You must authenticate with a valid API ID and secret. */
      401: {
        content: {
          "application/json": components["schemas"]["ApiErrorResponse"];
        };
      };
      /** Invalid IP address. */
      422: {
        content: {
          "application/json": components["schemas"]["ApiErrorResponse"];
        };
      };
    };
  };
  /**
   * Fetches a list of events for the host with the specified IP address.
   *
   * **Cursor Pagination**
   *
   * This endpoint relies on using cursors for efficient pagination. Each result may
   * return a `next` cursor value which can be used to fetch additional pages of results.
   * This endpoint only support forward-pagination.
   *
   * ```json
   * {
   *   "links": {
   *     "next": "nextCursorToken"
   *   },
   *   [Rest of Response]
   * }
   * ```
   * The returned cursor token values can be added to the endpoint as a `cursor`
   * parameter to fetch the next page of results.
   * The entire set of results can be iterated page-by-page using returned
   * cursors. If no cursor is given, the first page will be returned.
   */
  viewHostEvents: {
    parameters: {
      path: {
        /** The IP Address of the requested host. */
        ip: string;
      };
      query: {
        /**
         * An optional RFC3339 timestamp which represents the beginning
         * chronological point-in-time (inclusive) from which events
         * are returned. This must always be earlier than end_time.
         * Precision up to *nanoseconds* is observed and recommended.
         *
         * If not provided, this is assumed to be the historical API maximum.
         */
        start_time?: string;
        /**
         * An optional RFC3339 timestamp which represents the ending
         * chronological point-in-time (exclusive) from which events
         * are returned. This must always be later than start_time.
         * Precision up to *nanoseconds* is observed and recommended.
         *
         * If not provided, this is assumed to be now.
         */
        end_time?: string;
        /** The maximum number of hits to return in each response (minimum of 1, maximum of 50). */
        per_page?: number;
        /** Cursor token from the API response, which fetches the next or previous page of hits when added to the endpoint URL. */
        cursor?: string;
        /** Reverse the order of the return events, that is, return events in reversed chronological order. */
        reversed?: boolean;
      };
    };
    responses: {
      /** Events for the host were sucessfully retrieved. */
      200: {
        content: {
          "application/json": components["schemas"]["ApiResponse"] & {
            result?: {
              /** @example 1.1.1.1 */
              ip?: string;
              events?: components["schemas"]["HostEvent"][];
            };
          };
        };
      };
      /** You must authenticate with a valid API ID and secret. */
      401: {
        content: {
          "application/json": components["schemas"]["ApiErrorResponse"];
        };
      };
      /** Invalid IP address. */
      422: {
        content: {
          "application/json": components["schemas"]["ApiErrorResponse"];
        };
      };
    };
  };
  /** Fetches a list of host names for the specified IP address. */
  viewHostNames: {
    parameters: {
      path: {
        /** The IP Address of the requested host. */
        ip: string;
      };
      query: {
        /** The maximum number of hits to return in each response (minimum of 1, maximum of 1000). */
        per_page?: number;
        /** Cursor token from the API response, which fetches the next page of names when added to the endpoint URL. */
        cursor?: string;
      };
    };
    responses: {
      /** The host names were successfully retrieved. */
      200: {
        content: {
          "application/json": components["schemas"]["ApiResponse"] & {
            result?: {
              /**
               * @example [
               *   "google.com",
               *   "google.co.uk",
               *   "google.com.au",
               *   "..."
               * ]
               */
              names?: string[];
              links?: {
                /** @example nextCursorToken */
                next?: string;
              };
            };
          };
        };
      };
      /** You must authenticate with a valid API ID and secret. */
      401: {
        content: {
          "application/json": components["schemas"]["ApiErrorResponse"];
        };
      };
    };
  };
  /** Returns a list of comments on the given host. */
  getCommentsByHost: {
    parameters: {
      path: {
        /** The IP Address of the requested host. */
        ip: string;
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          "application/json": components["schemas"]["ApiResponse"] & {
            result?: {
              /** @example 1.1.1.1 */
              ip?: string;
              comments?: components["schemas"]["HostComment"][];
            };
          };
        };
      };
    };
  };
  /** Adds a comment on the given host. */
  addCommentByHost: {
    parameters: {
      path: {
        /** The IP Address of the requested host. */
        ip: string;
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          "application/json": components["schemas"]["ApiResponse"] & {
            result?: components["schemas"]["HostComment"];
          };
        };
      };
      /** Unprocessable Entity */
      422: {
        content: {
          "application/json": components["schemas"]["ApiErrorResponse"];
        };
      };
    };
    requestBody: {
      content: {
        "application/json": {
          /** @example **This is a comment.** */
          contents?: string;
        };
      };
    };
  };
  /** Returns a specific comment on the given host. */
  getCommentByHost: {
    parameters: {
      path: {
        /** The IP Address of the requested host. */
        ip: string;
        /** The ID of the requested comment. */
        comment_id: string;
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          "application/json": components["schemas"]["ApiResponse"] & {
            result?: components["schemas"]["HostComment"];
          };
        };
      };
      /** Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["ApiErrorResponse"];
        };
      };
      /** Unprocessable Entity */
      422: {
        content: {
          "application/json": components["schemas"]["ApiErrorResponse"];
        };
      };
    };
  };
  /** Updates a specific comment on the given host. */
  updateCommentByHost: {
    parameters: {
      path: {
        /** The IP Address of the requested host. */
        ip: string;
        /** The ID of the requested comment. */
        comment_id: string;
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          "application/json": components["schemas"]["ApiResponse"] & {
            result?: components["schemas"]["HostComment"];
          };
        };
      };
      /** Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["ApiErrorResponse"];
        };
      };
      /** Unprocessable Entity */
      422: {
        content: {
          "application/json": components["schemas"]["ApiErrorResponse"];
        };
      };
    };
    requestBody: {
      content: {
        "application/json": {
          /** @example **This is a comment.** */
          contents?: string;
        };
      };
    };
  };
  /** Deletes a specific comment on the given host. */
  deleteCommentByHost: {
    parameters: {
      path: {
        /** The IP Address of the requested host. */
        ip: string;
        /** The ID of the requested comment. */
        comment_id: string;
      };
    };
    responses: {
      /** No Content */
      204: never;
      /** Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["ApiErrorResponse"];
        };
      };
      /** Unprocessable Entity */
      422: {
        content: {
          "application/json": components["schemas"]["ApiErrorResponse"];
        };
      };
    };
  };
  /** The host metadata endpoint returns a list of services Censys scans for. These are the values that can be given as values for the `services.service_name` field in search queries. */
  getHostMetadata: {
    responses: {
      /** The metadata was retrieved. */
      200: {
        content: {
          "application/json": components["schemas"]["ApiResponse"] & {
            result?: {
              /**
               * @example [
               *   "HTTP",
               *   "IMAP",
               *   "MQTT",
               *   "SSH",
               *   "..."
               * ]
               */
              services?: string[];
            };
          };
        };
      };
    };
  };
  /**
   * Returns a list of hosts which contain services presenting this certificate,
   * including when the certificate was first observed.
   *
   * **Cursor Pagination**
   *
   * This endpoint relies on using cursors for efficient pagination. Each result may
   * return a `next` cursor value which can be used to fetch additional pages of results.
   * This endpoint only support forward-pagination.
   *
   * ```json
   * {
   *   "links": {
   *     "next": "nextCursorToken"
   *   },
   *   [Rest of Response]
   * }
   * ```
   * The returned cursor token values can be added to the endpoint as a `cursor`
   * parameter to fetch the next page of results.
   * The entire set of results can be iterated page-by-page using returned
   * cursors. If no cursor is given, the first page will be returned.
   */
  getHostsByCert: {
    parameters: {
      path: {
        /** The SHA-256 fingerprint of the requested certificate. */
        fingerprint: string;
      };
      query: {
        /** Cursor token from the API response, which fetches the next page of hosts when added to the endpoint URL. */
        cursor?: string;
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          "application/json": components["schemas"]["ApiResponse"] & {
            result?: {
              /** @description The SHA-256 fingerprint of the certificate. */
              fingerprint?: string;
              hosts?: {
                ip?: string;
                /** @description Name provided if host is a virtual host. */
                name?: string;
                /**
                 * Format: date-time
                 * @description Time when certificate was observed.
                 */
                observed_at?: string;
                /**
                 * Format: date-time
                 * @description Time when the certificate was first observed.
                 */
                first_observed_at?: string;
              }[];
              links?: {
                /** @example nextCursorToken */
                next?: string;
              };
            };
          };
        };
      };
    };
  };
  /** Returns a list of comments on the given certificate. */
  getCommentsByCert: {
    parameters: {
      path: {
        /** The SHA-256 fingerprint of the requested certificate. */
        fingerprint: string;
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          "application/json": components["schemas"]["ApiResponse"] & {
            result?: {
              /** @example 9d3b51a6b80daf76e074730f19dc01e643ca0c3127d8f48be64cf3302f6622cc */
              fingerprint?: string;
              comments?: components["schemas"]["CertComment"][];
            };
          };
        };
      };
    };
  };
  /** Adds a comment on the given certificate. */
  addCommentByCert: {
    parameters: {
      path: {
        /** The SHA-256 fingerprint of the requested certificate. */
        fingerprint: string;
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          "application/json": components["schemas"]["ApiResponse"] & {
            result?: components["schemas"]["CertComment"];
          };
        };
      };
    };
    requestBody: {
      content: {
        "application/json": {
          /** @example **This is a comment.** */
          contents?: string;
        };
      };
    };
  };
  /** Returns a comment on the given certificate. */
  getCommentByCert: {
    parameters: {
      path: {
        /** The SHA-256 fingerprint of the requested certificate. */
        fingerprint: string;
        /** The ID of the requested comment. */
        comment_id: string;
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          "application/json": components["schemas"]["ApiResponse"] & {
            result?: components["schemas"]["CertComment"];
          };
        };
      };
    };
  };
  /** Updates a comment on the given certificate. */
  updateCommentByCert: {
    parameters: {
      path: {
        /** The SHA-256 fingerprint of the requested certificate. */
        fingerprint: string;
        /** The ID of the requested comment. */
        comment_id: string;
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          "application/json": components["schemas"]["ApiResponse"] & {
            result?: components["schemas"]["CertComment"];
          };
        };
      };
      /** Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["ApiResponse"] & {
            /** @example Not Found */
            error?: string;
          };
        };
      };
    };
    requestBody: {
      content: {
        "application/json": {
          /** @example **This is a comment.** */
          contents?: string;
        };
      };
    };
  };
  /** Deletes a comment on the given certificate. */
  deleteCommentByCert: {
    parameters: {
      path: {
        /** The SHA-256 fingerprint of the requested certificate. */
        fingerprint: string;
        /** The ID of the requested comment. */
        comment_id: string;
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          "application/json": components["schemas"]["ApiResponse"] & {
            result?: {
              /** @example 9d3b51a6b80daf76e074730f19dc01e643ca0c3127d8f48be64cf3302f6622cc */
              fingerprint?: string;
              comments?: components["schemas"]["CertComment"][];
            };
          };
        };
      };
      /** Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["ApiResponse"] & {
            /** @example Not Found */
            error?: string;
          };
        };
      };
    };
  };
  /**
   * > The Censys legacy v1 API contains API endpoints which are being maintained until replacement v2 endpoints are available.
   *
   * The view endpoint returns the current structured data we have on a specific certificate.
   */
  viewCertificate: {
    parameters: {
      path: {
        /** The SHA-256 fingerprint of the requested certificate. */
        sha256: string;
      };
    };
    responses: {
      /** The record was successfully retrieved. */
      200: {
        content: {
          "application/json": components["schemas"]["Certificate"];
        };
      };
      /** The requested record does not exist. */
      404: {
        content: {
          "application/json": components["schemas"]["v1ApiErrorResponse"];
        };
      };
      /** Your query was not executed because you have exceeded your specified rate limit. */
      429: {
        content: {
          "application/json": components["schemas"]["v1ApiErrorResponse"];
        };
      };
      /** An unexpected error occurred when trying to execute your query. Try again at a later time or contact us at [support@censys.io](mailto:support@censys.io) if the problem persists. */
      500: {
        content: {
          "application/json": components["schemas"]["v1ApiErrorResponse"];
        };
      };
    };
  };
  /**
   * > The Censys legacy v1 API contains API endpoints which are being maintained until replacement v2 endpoints are available.
   *
   * The search endpoint allows searches against the current data in the Certificates index using the [legacy search syntax](https://search.censys.io/certificates/help). The endpoint returns a paginated result set of hosts (or websites or certificates) that match the search. Data should be posted as a JSON request document.
   */
  searchCertificates: {
    responses: {
      /** The search or query executed successfully. */
      200: {
        content: {
          "application/json": {
            /** @example ok */
            status?: string;
            metadata?: {
              /** @example 127530942 */
              count?: number;
              /** @example * */
              query?: string;
              /** @example 1 */
              page?: number;
              /** @example 1275310 */
              pages?: number;
            };
            results?: components["schemas"]["Certificate"][];
          };
        };
      };
      /** Your query could not be executed (e.g., query could not be parsed or timed out.) */
      400: {
        content: {
          "application/json": components["schemas"]["v1ApiErrorResponse"];
        };
      };
      /** Specified search index was not valid. */
      404: {
        content: {
          "application/json": components["schemas"]["v1ApiErrorResponse"];
        };
      };
      /** Your query was not executed because you have exceeded your specified rate limit. */
      429: {
        content: {
          "application/json": components["schemas"]["v1ApiErrorResponse"];
        };
      };
      /** An unexpected error occurred when trying to execute your query. Try again at a later time or contact us at [support@censys.io](mailto:support@censys.io) if the problem persists. */
      500: {
        content: {
          "application/json": components["schemas"]["v1ApiErrorResponse"];
        };
      };
    };
    requestBody: {
      content: {
        "application/json": {
          /** @example validation.nss.valid: true */
          query?: string;
          /** @example 1 */
          page?: number;
          fields?: string[];
          /** @example false */
          flatten?: boolean;
        };
      };
    };
  };
  /**
   * > The Censys legacy v1 API contains API endpoints which are being maintained until replacement v2 endpoints are available.
   *
   * The build report endpoint lets you run aggregate reports on the breakdown of a field in a result set analogous to the "Build Report" functionality in the front end.
   */
  generateCertificateReport: {
    responses: {
      /** The report was successfully generated. */
      200: {
        content: {
          "application/json": {
            /** @example ok */
            status?: string;
            /**
             * @example [
             *   {
             *     "key": "US",
             *     "doc_count": 1000
             *   },
             *   {
             *     "key": "CN",
             *     "doc_count": 100
             *   }
             * ]
             */
            results?: {
              key?: string;
              doc_count?: number;
            }[];
            metadata?: {
              /** @example parsed.names: 1.1.1.1 */
              query?: string;
              /** @example 2570 */
              count?: number;
              /** @example 50 */
              buckets?: number;
              /** @example 100 */
              backend_time?: number;
              /** @example 2000 */
              nonnull_count?: number;
              /** @example 10 */
              other_result_count?: number;
              /** @example 0 */
              error_bound?: number;
            };
          };
        };
      };
      /** Your query could not be executed (e.g., query could not be parsed or timed out.) */
      400: {
        content: {
          "application/json": components["schemas"]["v1ApiErrorResponse"];
        };
      };
      /** Your query was not executed because you have exceeded your specified rate limit. */
      429: {
        content: {
          "application/json": components["schemas"]["v1ApiErrorResponse"];
        };
      };
      /** An unexpected error occurred when trying to execute your query. Try again at a later time or contact us at [support@censys.io](mailto:support@censys.io) if the problem persists. */
      500: {
        content: {
          "application/json": components["schemas"]["v1ApiErrorResponse"];
        };
      };
    };
    requestBody: {
      content: {
        "application/json": {
          /** @example parsed.names: 1.1.1.1 */
          query?: string;
          /** @example parsed.issuer.country.raw */
          field?: string;
          /** @default 50 */
          buckets?: number;
        };
      };
    };
  };
  /**
   * > The Censys legacy v1 API contains API endpoints which are being maintained until replacement v2 endpoints are available.
   *
   * The bulk endpoint returns, in bulk, the current structured data on many specific certificates.
   *
   * Each requested certificate will be available as a key in the response, regardless of whether or not we know anything about them. Any certificates which we don't know anything about will be replaced by an error, as shown at the top of the example below.
   */
  bulkCertificateLookup: {
    responses: {
      /** The records were successfully retrieved. */
      200: {
        content: {
          "application/json": { [key: string]: string };
        };
      };
      /** Your query was not executed because you have exceeded your specified rate limit. */
      429: {
        content: {
          "application/json": components["schemas"]["v1ApiErrorResponse"];
        };
      };
      /** An unexpected error occurred when trying to execute your query. Try again at a later time or contact us at [support@censys.io](mailto:support@censys.io) if the problem persists. */
      500: {
        content: {
          "application/json": components["schemas"]["v1ApiErrorResponse"];
        };
      };
    };
    requestBody: {
      content: {
        "application/json": {
          /**
           * @example [
           *   "13a88367a15e4e0e9d77158c95e6718d9158ac1bc30619f29ba7bf7d5befc50f",
           *   "48177e03b47bdcb3b6ab28a92f8005b95302418cd5b9ede77a97eb918e4a2da2",
           *   "d1997c5365c6f2c8205ef8bf1e146dc9ab5bc61e74f3c2dc146e0a509352ea77"
           * ]
           */
          fingerprints?: string[];
        };
      };
    };
  };
  /**
   * > The Censys legacy v1 API contains API endpoints which are being maintained until replacement v2 endpoints are available.
   *
   * The Get Series endpoint returns a data on the types of scans we regularly perform (series).
   */
  getSeries: {
    responses: {
      /** We were able to successfully retrieve a list of series. */
      200: {
        content: {
          "application/json": {
            primary_series?: { [key: string]: string };
            raw_series?: { [key: string]: string };
          };
        };
      };
      /** Your query was not executed because you have exceeded your specified rate limit. */
      429: {
        content: {
          "application/json": components["schemas"]["v1ApiErrorResponse"];
        };
      };
      /** An unexpected error occurred when trying to execute your query. Try again at a later time or contact us at [support@censys.io](mailto:support@censys.io) if the problem persists. */
      500: {
        content: {
          "application/json": components["schemas"]["v1ApiErrorResponse"];
        };
      };
    };
  };
  /**
   * > The Censys legacy v1 API contains API endpoints which are being maintained until replacement v2 endpoints are available.
   *
   * The View Series endpoint returns data we have about a particular series—a scan of the same protocol and destination across time—including the list of scans.
   */
  viewSeries: {
    parameters: {
      path: {
        /** The ID of the series. */
        series: string;
      };
    };
    responses: {
      /** We were able to successfully retrieve a series. */
      200: {
        content: {
          "application/json": {
            /** @example certificates-daily-added */
            id?: string;
            /** @example Certificates by date added */
            name?: string;
            /** @example ... */
            description?: string;
            results?: {
              /**
               * @example [
               *   {
               *     "id": "20150912T1329",
               *     "timestamp": "20150912T132919",
               *     "details_url": "https://..."
               *   },
               *   {
               *     "id": "20150930T0056",
               *     "timestamp": "20150930T005634",
               *     "details_url": "https://..."
               *   }
               * ]
               */
              historical?: {
                id?: string;
                timestamp?: string;
                details_url?: string;
              }[];
              /**
               * @example {
               *   "id": "20150930T0056",
               *   "timestamp": "20150930T005634",
               *   "details_url": "https://..."
               * }
               */
              latest?: {
                id?: string;
                timestamp?: string;
                details_url?: string;
              };
            };
          };
        };
      };
      /** The requested series does not exist. */
      404: {
        content: {
          "application/json": components["schemas"]["v1ApiErrorResponse"];
        };
      };
      /** Your query was not executed because you have exceeded your specified rate limit. */
      429: {
        content: {
          "application/json": components["schemas"]["v1ApiErrorResponse"];
        };
      };
      /** An unexpected error occurred when trying to execute your query. Try again at a later time or contact us at [support@censys.io](mailto:support@censys.io) if the problem persists. */
      500: {
        content: {
          "application/json": components["schemas"]["v1ApiErrorResponse"];
        };
      };
    };
  };
  /**
   * > The Censys legacy v1 API contains API endpoints which are being maintained until replacement v2 endpoints are available.
   *
   * The View Result endpoint returns data on a particular scan (result), as found in the Get Series or View Series endpoints.
   */
  viewResult: {
    parameters: {
      path: {
        /** The ID of the series. */
        series: string;
        /** The ID of the result. */
        result: string;
      };
    };
    responses: {
      /** We were able to successfully retrieve a result. */
      200: {
        content: {
          "application/json": {
            /** @example 20150930T0056 */
            id?: string;
            /** @example 20150930T005634 */
            timestamp?: string;
            files?: {
              "zmap-results"?: {
                /** @example csv */
                file_type?: string;
                schema?: { [key: string]: unknown };
                /** @example https://... */
                download_path?: string;
                /** @example 693b6bdd6b954aed3981ca9d801bb1317bfdb19f560f968781823b9abef8eaa3 */
                sha256_fingerprint?: string;
                /** @example 304 */
                size?: number;
              };
              "zgrab-results"?: {
                /** @example csv */
                file_type?: string;
                schema?: {
                  timestamp?: {
                    /** @example date */
                    type?: string;
                  };
                  ip?: {
                    /** @example ip */
                    type?: string;
                  };
                };
                /** @example https://... */
                download_path?: string;
                /** @example 693b6bdd6b954aed3981ca9d801bb1317bfdb19f560f968781823b9abef8eaa3 */
                sha256_fingerprint?: string;
                /** @example 304 */
                size?: number;
              } & { [key: string]: { [key: string]: unknown } };
              /** @example https://... */
              download_path?: string;
              /** @example cdd962fe956674749ef5d40d59c423a0be77432a246bcd223c3346576c9479ff */
              sha256_fingerprint?: string;
              /** @example 21707 */
              size?: number;
            };
          };
        };
      };
      /** The requested series or result does not exist. */
      404: {
        content: {
          "application/json": components["schemas"]["v1ApiErrorResponse"];
        };
      };
      /** Your query was not executed because you have exceeded your specified rate limit. */
      429: {
        content: {
          "application/json": components["schemas"]["v1ApiErrorResponse"];
        };
      };
      /** An unexpected error occurred when trying to execute your query. Try again at a later time or contact us at [support@censys.io](mailto:support@censys.io) if the problem persists. */
      500: {
        content: {
          "application/json": components["schemas"]["v1ApiErrorResponse"];
        };
      };
    };
  };
  /**
   * > The Censys legacy v1 API contains API endpoints which are being maintained until replacement v2 endpoints are available.
   *
   * The Account endpoint returns information about your Censys account. Most importantly, you can use this endpoint to check on your current query quota usage.
   */
  account: {
    responses: {
      /** Account information was successfully retrieved. */
      200: {
        content: {
          "application/json": {
            /** @example john_doe */
            login?: string;
            /** @example john@example.com */
            email?: string;
            /** @example 2018-01-01 12:00:00 */
            first_login?: string;
            /** @example 2021-01-01 12:00:00 */
            last_login?: string;
            quota?: {
              /** @example 10 */
              used?: number;
              /** @example 2021-02-01 12:00:00 */
              resets_at?: string;
              /** @example 250 */
              allowance?: number;
            };
          };
        };
      };
      /** Your request did not include a valid Authorization header. */
      403: {
        content: {
          "application/json": components["schemas"]["v1ApiErrorResponse"];
        };
      };
      /** Your query was not executed because you have exceeded your specified rate limit. */
      429: {
        content: {
          "application/json": components["schemas"]["v1ApiErrorResponse"];
        };
      };
      /** An unexpected error occurred when trying to execute your query. Try again at a later time or contact us at [support@censys.io](mailto:support@censys.io) if the problem persists. */
      500: {
        content: {
          "application/json": components["schemas"]["v1ApiErrorResponse"];
        };
      };
    };
  };
  /** Returns a list of all tags for a team */
  listTags: {
    responses: {
      /** OK */
      200: {
        content: {
          "application/json": components["schemas"]["ApiResponse"] & {
            result?: {
              tags?: components["schemas"]["Tag"][];
            };
          };
        };
      };
    };
  };
  /** Creates a new tag for a team */
  createTag: {
    responses: {
      /** OK */
      200: {
        content: {
          "application/json": components["schemas"]["ApiResponse"] & {
            result?: components["schemas"]["Tag"];
          };
        };
      };
    };
    /** Tag to create */
    requestBody: {
      content: {
        "application/json": components["schemas"]["Tag"];
      };
    };
  };
  /** Returns a tag for a team */
  getTag: {
    parameters: {
      path: {
        /** The unique ID of the tag. */
        id: string;
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          "application/json": components["schemas"]["ApiResponse"] & {
            result?: components["schemas"]["Tag"];
          };
        };
      };
    };
  };
  /** Updates a tag for a team */
  updateTag: {
    parameters: {
      path: {
        /** The unique ID of the tag. */
        id: string;
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          "application/json": components["schemas"]["ApiResponse"] & {
            result?: components["schemas"]["Tag"];
          };
        };
      };
    };
    /** Tag to update */
    requestBody: {
      content: {
        "application/json": components["schemas"]["Tag"];
      };
    };
  };
  /** Deletes a tag for a team */
  deleteTag: {
    parameters: {
      path: {
        /** The unique ID of the tag. */
        id: string;
      };
    };
    responses: {
      /** No Content */
      204: never;
    };
  };
  /** Returns a list of hosts for a tag */
  listHostsForTag: {
    parameters: {
      path: {
        /** The unique ID of the tag. */
        id: string;
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          "application/json": components["schemas"]["ApiResponse"] & {
            result?: {
              hosts?: {
                /** @example 1.1.1.1 */
                ip?: string;
                /**
                 * Format: date-time
                 * @example 2021-01-01T12:00:00.000000Z
                 */
                tagged_at?: string;
              }[];
            };
          };
        };
      };
    };
  };
  /** Returns a list of certificates for a tag */
  listCertificatesForTag: {
    parameters: {
      path: {
        /** The unique ID of the tag. */
        id: string;
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          "application/json": components["schemas"]["ApiResponse"] & {
            result?: {
              certs?: {
                /** @example e58e89a726d80bb0219b218c3ab9d818b4be75d77959508400d660ebe1c1be3d */
                fingerprint?: string;
                /**
                 * Format: date-time
                 * @example 2021-01-01T12:00:00.000000Z
                 */
                tagged_at?: string;
              }[];
            };
          };
        };
      };
    };
  };
  /** Returns a list of tags on the given host. */
  getTagsByHost: {
    parameters: {
      path: {
        /** The IP Address of the requested host. */
        ip: string;
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          "application/json": components["schemas"]["ApiResponse"] & {
            result?: {
              /** @example 1.1.1.1 */
              ip?: string;
              tags?: components["schemas"]["Tag"][];
            };
          };
        };
      };
    };
  };
  /** Adds a tag on the given host. */
  tagHost: {
    parameters: {
      path: {
        /** The IP Address of the requested host. */
        ip: string;
        /** The unique ID of the tag. */
        id: string;
      };
    };
    responses: {
      /** No Content */
      204: never;
    };
  };
  /** Removes a tag on the given host. */
  untagHost: {
    parameters: {
      path: {
        /** The IP Address of the requested host. */
        ip: string;
        /** The unique ID of the tag. */
        id: string;
      };
    };
    responses: {
      /** No Content */
      204: never;
    };
  };
  /** Returns a list of tags on the given certificate. */
  getTagsByCert: {
    parameters: {
      path: {
        /** The SHA-256 fingerprint of the requested certificate. */
        fingerprint: string;
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          "application/json": components["schemas"]["ApiResponse"] & {
            result?: {
              /** @example 9d3b51a6b80daf76e074730f19dc01e643ca0c3127d8f48be64cf3302f6622cc */
              fingerprint?: string;
              tags?: components["schemas"]["Tag"][];
            };
          };
        };
      };
    };
  };
  /** Adds a tag on the given certificate. */
  tagCert: {
    parameters: {
      path: {
        /** The SHA-256 fingerprint of the requested certificate. */
        fingerprint: string;
        /** The unique ID of the tag. */
        id: string;
      };
    };
    responses: {
      /** No Content */
      204: never;
    };
  };
  /** Removes a tag on the given certificate. */
  untagCert: {
    parameters: {
      path: {
        /** The SHA-256 fingerprint of the requested certificate. */
        fingerprint: string;
        /** The unique ID of the tag. */
        id: string;
      };
    };
    responses: {
      /** No Content */
      204: never;
    };
  };
}

export interface external {}
